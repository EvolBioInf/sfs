/***** sample.c **************************************
 * Description: Functions for manipulating a sample
 *   generated by Hudson's ms program.
 * Reference: Hudson, R. R. (2002). Generating samples
 *   under a Wright-Fisher neutral model of genetic 
 *   variation. Bioinformatics 18: 337-338.
 * Author: Bernhard Haubold, haubold@evolbio.mpg.de
 * Date: Tue Aug 14 20:35:23 2007.
 * License: GNU General Public
 *****************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <unistd.h>
#include <fcntl.h>
#include "eprintf.h"
#include "interface.h"
#include "sample.h"
#include "ran.h"
#include "sequence_data.h"
#include "stringUtil.h"

#define MAXLEN 1000

Sample *sample;
Args *args;
FILE *fp;
int sampleCounter;

void expandSample();
void getTemplate(char *file);

int comp(const void *v1, const void *v2){
     return (*(int *)v1 - *(int *)v2);
}


Sample *initializeSample(FILE *filePointer, Args *arguments){
  char *token;
  int i, idum;
  FILE *fpra;

  args = arguments;
  fp = filePointer;
  sampleCounter = 0;
  
  sample = (Sample *)emalloc(sizeof(Sample));
  sample->line = (char *)emalloc((MAXLEN+1) * sizeof(char));
  sample->line[0] = '\0';
  /* get first line of input; this contains the command with which ms was started */
  sample->line = fgets(sample->line, MAXLEN, fp);
  token = strtok(sample->line, " ");
  token = strtok(NULL, " ");
  sample->nsam = atoi(token);
  if(args->a){
    token = strtok(NULL, " ");
    sample->nsite = atoi(token);
    sample->howmany = 1;
  }else{
    token = strtok(NULL, " ");
    sample->howmany = atoi(token);
    sample->nsite = 0;
  }
  sample->npop = 1;
  sample->sampleSizes = NULL;
  while((token = strtok(NULL, " ")) != NULL){
    if(strcmp(token, "-r") == 0){
      token = strtok(NULL, " ");
      if(!args->a){
	token = strtok(NULL, " ");
	sample->nsite = atoi(token);
      }
    }else if(strcmp(token, "-I") == 0){
      token = strtok(NULL, " ");
      sample->npop = atoi(token);
      sample->sampleSizes = (int *)emalloc(sample->npop*sizeof(int));
      for(i=0;i<sample->npop;i++){
	token = strtok(NULL, " ");
	sample->sampleSizes[i] = atoi(token);
      }
    }
  }
  if(sample->nsite == 0 && args->a){
    fprintf(stderr,"ERROR [sample.c]: please use ms with the -r switch.\n");
    exit(-1);
  }
  sample->seq = (char **)emalloc(2 * sizeof(char *));
  /* if(args->t) */
  /*   getTemplate(args->t); */
  /* else{ */
    sample->seq[0] = (char *)emalloc((sample->nsite + 1) * sizeof(char));
    sample->seq[1] = (char *)emalloc((sample->nsite + 1) * sizeof(char));
  /* } */
  sample->maxlen = 1;
  sample->segsites = 0;
  sample->haplotypes = (char **)emalloc((sample->nsam + 1)*sizeof(char *));
  for(i=0;i<sample->nsam;i++){
    sample->haplotypes[i] = (char *)emalloc((sample->maxlen + 1)*sizeof(char));
  }
  sample->map = (int *)emalloc(sample->maxlen * sizeof(int));
  sample->positions = (float *)emalloc(sample->maxlen*sizeof(float));

  /* seed and initialize random number generator */
  if(args->s != 0){
    idum = args->s;
  }else if((fpra = fopen("randomSeed.dat","r")) != NULL){
    if(!fscanf(fpra,"%d",&idum))
      printf("WARNING[sample.initializeSample]: Something is wrong writing the the seed of the random number generator to file.\n");
    fclose(fpra);
  }else
    idum = -time(NULL); 
  init_genrand(idum);
  return sample;
}

void getTemplate(char *file){
  int fd;
  Sequence *sequence;
  int *dic, i;

  if ((fd = open (file, O_RDONLY, 0)) == 0)
    eprintf("ERROR [ms2dna]: cannot open template file %s for reading\n", file);
  sequence = read_fasta(fd);
  close(fd);

  if(sequence->num_seq > 1){
    printf("ERROR[ms2dna]: the template file contains %d sequences\n",sequence->num_seq);
    printf("\tbut the program can only deal with template files containing a single sequence.\n");
    exit(0);
  }
  sequence->len--;
  if(sequence->len != sample->nsite){
    printf("ERROR[ms2dna]: the template file contains %ld nucleotides,\n",sequence->len);
    printf("\tbut the ms simulation deals with %d sites.\n",sample->nsite);
    printf("\tthese two numbers need to be identical.\n");
    exit(0);
  }
  dic = NULL;
  dic = get_restricted_dna_dictionary(dic);
  for(i=0;i<sequence->len;i++)
    if(!dic[(int)sequence->seq[i]]){
      printf("ERROR[ms2dna]: the template sequence contains residues other than [acgtACGT] at position %d: %c.\n",i,sequence->seq[i]);
      exit(0);
    }
  strtoupper(sequence->seq);
  sample->seq[0] = sequence->seq;
  sample->seq[1] = (char *)emalloc((sample->nsite + 1) * sizeof(char));
}

/* getSample: read a haplotype sample from a file pointer assumed to be open */
Sample *getSample(int isMacs){
  int i;
  char *dum;
  double r1, r2;

  dum = (char *)emalloc(250*sizeof(char));
  while(fgets(sample->line,MAXLEN,fp) != NULL){
    if(sample->line[0] == 's'){
      sscanf(sample->line, "segsites: %d", &sample->segsites);
      if(sample->segsites >= sample->maxlen){
	sample->maxlen = sample->segsites+1;
	expandSample(sample);
      }
      if(!fscanf(fp,"%s",dum)){
	printf("ERROR[sample.getSample()]: Cannot read seed for random number generator from file.\n");
	exit(-1);
      }
      if(sample->segsites > 0){
	for(i=0;i<sample->segsites;i++)
	  if(!fscanf(fp, "%f", sample->positions + i))
	    printf("WARNING[smple.getSample()]-1: Something is wrong with reading the sample.\n");
	if(!isMacs){
	  /* generate extra significant digits for ms output, as ms only generates 4 */
	  for(i=0;i<sample->segsites;i++){
	    r1 = genrand_real1();
	    r2 = genrand_real1();
	    r2 /= 10000;
	    if(r1>0.5 && sample->positions[i] - r2 >= 0)
	      sample->positions[i] -= r2;
	    else if(sample->positions[i] + r2 <= 1.0)
	      sample->positions[i] += r2;
	  }
	}
	for(i=0;i<sample->nsam;i++){
	  if(!fscanf(fp," %s",sample->haplotypes[i]))
	    printf("WARNING[smple.getSample()]-2: Something is wrong with reading the sample.\n");
	}
      }
      free(dum);
      return sample;
    }
  }
  free(dum);
  return NULL;
}

/* void outputSample(FILE *fpo){ */
/*   int i, j, stepsRight, stepsLeft; */
/*   double r1, r2; */
/*   int p; */
/*   char nuc; */

/*   if(!args->t){ */
/*     /\* generate ancestral sequence *\/ */
/*     for(i=0;i<sample->nsite;i++){ */
/*       r1 = genrand_real1(); */
/*       r2 = genrand_real1(); */
/*       if(r1 <= args->g){ */
/* 	if(r2 <= 0.5) */
/* 	  sample->seq[0][i] = 'G'; */
/* 	else */
/* 	  sample->seq[0][i] = 'C'; */
/*       }else{ */
/* 	if(r2 <= 0.5) */
/* 	  sample->seq[0][i] = 'A'; */
/* 	else */
/* 	  sample->seq[0][i] = 'T'; */
/*       } */
/*     } */
/*   } */
/*   for(i=0;i<sample->nsite;i++) */
/*     sample->seq[1][i] = 'x'; */
/*   if(sample->segsites > sample->nsite){ */
/*     printf("#WARNING: number of segregating sites (%d) > number of mutable sites (%d)\n",sample->segsites,sample->nsite); */
/*     printf("#Are you dealing with macs input? If so, please use the -a option.\n"); */
/*   } */
/*   /\* map segregating sites onto sequence positions *\/ */
/*   for(i=0;i<sample->segsites;i++){ */
/*     p = sample->positions[i] * sample->nsite; */
/*     while(sample->seq[1][p] != 'x'){ /\* check for double hits *\/ */
/*       if(args->m == 0){ */
/* 	p = genrand_real1() * sample->nsite; */
/*       }else if(args->m == 1){              */
/* 	stepsLeft = 0; */
/* 	stepsRight = 0; */
/* 	/\* walk to the right *\/ */
/* 	for(j=p+1;j<sample->nsite;j++){ */
/* 	  stepsRight++; */
/* 	  if(sample->seq[1][j] == 'x') */
/* 	    break; */
/* 	} */
/* 	/\* walk to the left *\/ */
/* 	j = (p-1 > 0) ? p-1 : 0; */
/* 	if(j){ */
/* 	  for(;j>=0;j--){ */
/* 	    stepsLeft++; */
/* 	    if(sample->seq[1][j] == 'x') */
/* 	      break; */
/* 	  } */
/* 	} */
/* 	if((stepsLeft > 0) && (stepsLeft < stepsRight)) */
/* 	  p -= stepsLeft; */
/* 	else */
/* 	  p += stepsRight; */
/*       } */
/*     } */
/*     sample->map[i] = p; */
/*     sample->seq[1][p] = 'y'; */
/*   } */
/*   /\* map the last segregating site to nonsense *\/ */
/*   sample->map[sample->segsites] = -1; */
/*   /\* generate nucleotides for mutant positions *\/ */
/*   for(i=0;i<sample->segsites;i++){ */
/*     r1 = genrand_real1(); */
/*     r2 = genrand_real1(); */
/*     p = sample->map[i]; */
/*     if(r1 <= args->g){                    /\* is the derived state G/C? *\/ */
/*       if(sample->seq[0][p] == 'G')          /\* is the ancestral state G? *\/ */
/* 	nuc = 'C';                            /\* mutate to C *\/ */
/*       else if(sample->seq[0][p] == 'C')     /\* is the ancestral state C? *\/ */
/* 	nuc = 'G';                            /\* mutate to G *\/ */
/*       else                                  /\* is the ancestral state A/T? *\/ */
/* 	if(r2 <= 0.5)                         /\* draw equiprobable G or C *\/ */
/* 	  nuc = 'G'; */
/* 	else */
/* 	  nuc = 'C'; */
/*     }else{                                /\* is the derived state A/T? *\/ */
/*       if(sample->seq[0][p] == 'A')          /\* is the ancestral state A? *\/ */
/* 	nuc = 'T';                            /\* mutate to T *\/ */
/*       else if(sample->seq[0][p] == 'T')     /\* is the ancestral state T? *\/ */
/* 	nuc = 'A';                            /\* mutate to A *\/ */
/*       else                                  /\* is the ancestral state G/C? *\/ */
/* 	if(r2 <= 0.5)                         /\* draw equiprobable A or T *\/ */
/* 	  nuc = 'A'; */
/* 	else */
/* 	  nuc = 'T'; */
/*     } */
/*     sample->seq[1][p] = nuc; */
/*   } */
/*   sampleCounter++; */
/*   if(args->f == 0) */
/*     printFasta(fpo); */
/*   else if(args->f == 1) */
/*     printIma(fpo); */
/*   else if(args->f == 2) */
/*     printGenetree(fpo); */
/* } */

void printGenetree(FILE *fpo){

}

void printIma(FILE *fpo){
  int cc;  /* character chounter */
  int i, j, k;
  int ns;  /* number of segregating sites */
  int pc;  /* population counter */
  int sc;  /* sequence counter (within population) */
  int maxLen = 10;

  pc = 0;
  sc = 0;
  fprintf(fpo,"L_%d %d %d %d I 1\n",sampleCounter,
	  sample->sampleSizes[0],sample->sampleSizes[1],sample->nsite);
  for(i=0;i<sample->nsam;i++){
    if(sc == sample->sampleSizes[pc]){
      sc = 0;
      pc++;
    }
    sc++;
    sprintf(sample->line,"P%d_S%d",pc+1,sc);
    cc = strlen(sample->line) < maxLen ? strlen(sample->line) : maxLen;
    /* print 10 characters of haplotype label */
    for(j=0;j<cc;j++)
      fprintf(fpo,"%c",sample->line[j]);
    for(k=j;k<10;k++)
      fprintf(fpo,"%c",' ');
    /* print haplotype */
    ns = 0;
    for(j=0;j<sample->nsite;j++){
      if(j == sample->map[ns]){   /* print derived nucleotide */
	ns++;
	fprintf(fpo,"%c",sample->seq[1][j]);
      }else                       /* print ancestral nucleotide */
	fprintf(fpo,"%c",sample->seq[0][j]);
    }
    fprintf(fpo,"%s","\n");
  }
}

void printFasta(FILE *fpo){
  int ns;  /* segregating sites counter */
  int nc;  /* nucleotide counter */
  int sc;  /* sequence counter (within population) */
  int pc;  /* population counter */
  int i, j;
  int lineLen;

  lineLen = 70;
  nc = 0;
  sc = 0;
  pc = 0;
  for(i=0;i<sample->nsam;i++){
    fprintf(fpo,">");
    if(sample->howmany > 1)
      fprintf(fpo,"L%d",sampleCounter);
    if(sample->npop > 1){
      if(sample->nsam > 1)
	fprintf(fpo,"_P%d",pc+1);
      else
	fprintf(fpo,"P%d",pc+1);
    }
    if(sample->npop > 1 || sample->howmany > 1)
      fprintf(fpo,"_S%d\n",++sc);
    else
      fprintf(fpo,"S%d\n",++sc);
    if(sample->npop > 1){
      if(sc == sample->sampleSizes[pc]){
	sc = 0;
	pc++;
      }
    }
    /* print haplotype */
    nc = 0;
    ns = 0;
    qsort(sample->map,sample->segsites,sizeof(int),comp);
    for(j=0;j<sample->nsite;j++){
      if(ns >= sample->maxlen)
	printf("ns: %d; sample->maxlen: %d\n",ns,sample->maxlen);
      if(j == sample->map[ns]){ /* mutant position */
	if(sample->haplotypes[i][ns] == '1'){ /* print derived nucleotide */
	  if(!args->c){
	    fprintf(fpo,"%c",sample->seq[1][j]);
	  }else{
	    if((j+1)%3 == 0)
	      fprintf(fpo,"%c",sample->seq[1][j]);
	    else
	      fprintf(fpo,"%c",sample->seq[0][j]);
	  }
	}else                                 /* print ancestral nucleotide */
	  fprintf(fpo,"%c",sample->seq[0][j]);
	ns++;
      }else
	fprintf(fpo,"%c",sample->seq[0][j]);
      nc++;
      if(nc == lineLen && j < sample->nsite - 1){
	fprintf(fpo,"\n");
	nc = 0;
      }
    }
/*     if(nc != lineLen) */
      fprintf(fpo,"\n");
  }
}

/* increase space for individual haplotypes
 */
void expandSample(){
  int i;

  for(i=0;i<sample->nsam;i++)
    sample->haplotypes[i] = (char *)erealloc(sample->haplotypes[i],sample->maxlen*sizeof(char));
  sample->map = (int *)erealloc(sample->map,sample->maxlen*sizeof(int));
  sample->positions = (float *)erealloc(sample->positions,sample->maxlen*sizeof(float));
  
}

/* freeSample: clean up after run of program:
 * 1) free memory
 * 2) update seed for random number generator
 */
void freeSample(){
  int i;
  FILE *fpra;

  for(i=0;i<sample->nsam;i++){
    free(sample->haplotypes[i]);
  }
  free(sample->haplotypes);
  free(sample->positions);
  free(sample->map);
  free(sample->seq[0]);
  free(sample->seq[1]);
  free(sample->seq);
  if(sample->sampleSizes)
    free(sample->sampleSizes);
  free(sample->line);
  free(sample);
  /* save seed of random number generator */
  if(args->s == 0){
    fpra = fopen("randomSeed.dat","w");
    fprintf(fpra,"%d\n",(int)genrand_int32());
    fclose(fpra);
  }
}
